<script>
  let allWords = [];
  let pool = [];
  let activeWords = [];
  const MAX_ACTIVE = 6;
  const REQUIRED_CORRECT = 3;

  let score = 0;
  let isMuted = false;
  let completed = 0;

  const scoreDisplay = document.getElementById("score");
  const muteBtn = document.getElementById("muteBtn");
  const replayBtn = document.getElementById("replayBtn");
  const leftCol = document.getElementById("left");
  const rightCol = document.getElementById("right");
  const message = document.getElementById("message");

  const progressText = document.getElementById("progressText");
  const progressFill = document.getElementById("progressFill");

  let leftSelected = null;
  let rightSelected = null;

  // ===== Helper =====
  function shuffle(array) {
    return array.sort(() => Math.random() - 0.5);
  }

  function saveProgress() {
    const data = {
      allWords: allWords.map(w => ({ en: w.en, def: w.def, correctCount: w.correctCount || 0 })),
      pool: pool.map(w => ({ en: w.en, def: w.def, correctCount: w.correctCount || 0 })),
      activeWords: activeWords.map(w => ({ en: w.en, def: w.def, correctCount: w.correctCount || 0 })),
      score,
      completed
    };
    localStorage.setItem("travelVocabProgress", JSON.stringify(data));
  }

  function loadProgress() {
    const saved = localStorage.getItem("travelVocabProgress");
    if (saved) {
      try {
        const data = JSON.parse(saved);
        allWords = data.allWords;
        pool = data.pool;
        activeWords = data.activeWords;
        score = data.score;
        completed = data.completed;
        scoreDisplay.innerText = "Score: " + score;
        updateProgress();
        return true;
      } catch (e) {
        console.error("è¼‰å…¥é€²åº¦å¤±æ•—", e);
      }
    }
    return false;
  }

  function renderBoard() {
    leftCol.innerHTML = "";
    rightCol.innerHTML = "";

    const leftCards = shuffle([...activeWords]);
    const rightCards = shuffle([...activeWords]);

    leftCards.forEach(w => {
      const card = document.createElement("div");
      card.classList.add("card");
      card.innerText = w.en;
      card.dataset.en = w.en;
      card.dataset.def = w.def;
      card.addEventListener("click", () => selectCard(card, "left"));
      leftCol.appendChild(card);
    });

    rightCards.forEach(w => {
      const card = document.createElement("div");
      card.classList.add("card");
      card.innerText = w.def;
      card.dataset.en = w.en;
      card.dataset.def = w.def;
      card.addEventListener("click", () => selectCard(card, "right"));
      rightCol.appendChild(card);
    });
  }

  function updateScore(points) {
    score += points;
    scoreDisplay.innerText = "Score: " + score;
    saveProgress();
  }

  function updateProgress() {
    progressText.innerText = `Completed: ${completed} / ${allWords.length}`;
    const percent = (completed / allWords.length) * 100;
    progressFill.style.width = percent + "%";
    saveProgress();
  }

  function speakWord(word) {
    if (isMuted) return;
    const utterance = new SpeechSynthesisUtterance(word);
    utterance.lang = "en-US";
    speechSynthesis.speak(utterance);
  }

  function selectCard(card, side) {
    if (card.classList.contains("matched")) return;

    if (side === "left") {
      if (leftSelected) leftSelected.classList.remove("selected");
      leftSelected = card;
      card.classList.add("selected");
    } else {
      if (rightSelected) rightSelected.classList.remove("selected");
      rightSelected = card;
      card.classList.add("selected");
    }

    if (leftSelected && rightSelected) {
      checkMatch();
    }
  }

  function checkMatch() {
    const enWordLeft = leftSelected.dataset.en;
    const enWordRight = rightSelected.dataset.en;

    if (enWordLeft === enWordRight) {
      updateScore(10);
      speakWord(enWordLeft);

      const wordObj = allWords.find(w => w.en === enWordLeft);
      wordObj.correctCount = (wordObj.correctCount || 0) + 1;

      activeWords = activeWords.filter(w => w.en !== enWordLeft);
      leftSelected.remove();
      rightSelected.remove();

      if (wordObj.correctCount >= REQUIRED_CORRECT) {
        completed++;
      } else {
        // 30 ç§’å¾Œå†å›ä¾†
        setTimeout(() => {
          pool.push(wordObj);
          if (activeWords.length < MAX_ACTIVE && pool.length > 0) {
            const newWord = pool.shift();
            activeWords.push(newWord);
            renderBoard();
            saveProgress();
          }
        }, 30000);
      }

      if (pool.length > 0 && activeWords.length < MAX_ACTIVE) {
        const newWord = pool.shift();
        activeWords.push(newWord);
      }

      if (activeWords.length === 0 && pool.length === 0) {
        message.innerText = `ğŸ‰ All matched (3x)! Final Score: ${score}`;
      } else {
        renderBoard();
      }

      updateProgress();
    } else {
      updateScore(-2);
      const l = leftSelected;
      const r = rightSelected;
      setTimeout(() => {
        if (l) l.classList.remove("selected");
        if (r) r.classList.remove("selected");
      }, 400);
    }

    leftSelected = null;
    rightSelected = null;
    saveProgress();
  }

  // ===== Buttons =====
  muteBtn.addEventListener("click", () => {
    isMuted = !isMuted;
    muteBtn.textContent = isMuted ? "ğŸ”‡" : "ğŸ”Š";
  });

  replayBtn.addEventListener("click", () => {
    localStorage.removeItem("travelVocabProgress");
    location.reload();
  });

  // ===== Init =====
  fetch("travel_words.txt")
    .then(res => res.text())
    .then(text => {
      if (!loadProgress()) {
        allWords = text.trim().split("\n").map(line => {
          const [en, def] = line.split(",");
          return { en: en.trim(), def: def.trim(), correctCount: 0 };
        });
        pool = [...allWords];
        activeWords = pool.splice(0, MAX_ACTIVE);
        completed = 0;
        score = 0;
      }
      renderBoard();
      updateProgress();
    })
    .catch(err => {
      console.error("è®€å– travel_words.txt å¤±æ•—", err);
    });
</script>
